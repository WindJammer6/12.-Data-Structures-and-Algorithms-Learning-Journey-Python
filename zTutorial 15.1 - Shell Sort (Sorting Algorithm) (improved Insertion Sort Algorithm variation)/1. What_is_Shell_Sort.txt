Quick note, I watched through the codebasics' video on the Shell Sort Algorithm and didn't like how he 
visually explained Shell Sort. His visualised explanation captures the concept of Shell Sort, but the
visualised explanation was not close at all to how the Shell Sort operates algorithmically at all.

Hence, I sourced from 2 other websites for a better explanation (especially algorithmically):
1. Geekific Youtube Channel's video explaining Shell Sort Algorithm in Java
   -> Link: https://www.youtube.com/watch?v=IViqgakt-Eg
2. GeeksforGeeks Youtube Channel's video on an animation on the process of Shell Sort Algorithm
   -> Links: https://www.youtube.com/watch?v=SHcPqUe2GZM&t=1s


//////////////////////////////////////////////


What is Shell Sort?
Shell Sort is mainly an optimised variation of Insertion Sort. 

Shell Sort is a sorting algorithm that sorts a list by dividing the array into smaller subarrays and sort 
each of these subarrays using Insertion Sort Algorithm. The key difference is that the elements within each 
subarray are not adjacent, but are separated by a certain gap (Shell Sort Algorithm leverages on the idea
of gaps). This gap is initially larger, and after each gap's iteration of sorting via Insertion Sort of 
these smaller subarrays, the gap is gradually reduced during the sorting process until it reaches 1, at 
which when the gap is 1, this gap's (1) iteration of sorting transitions into a standard Insertion Sort 
Algorithm.


//////////////////////////////////////////////


Is the Shell Sort Algorithm implemented iteratively or recursively?

Shell Sort Algorithm is more commonly implemented iteratively. (implementing it recursively is possible
but its not very useful or practical)

In this tutorial we will be learning how to implement Shell Sort iteratively.


//////////////////////////////////////////////


To better understand Shell Sort Algorithm, lets look at the problem of Insertion Sort Algorithm that 
Shell Sort Algorithm tries to solve.

So what is the problem of Insertion Sort Algorithm that Shell Sort Algorithm solves?


(You can refer to the steps of Insertion Sort Algorithm in '1. What_is_Insertion_Sort.txt' (Steps 1 to 4) and 
'2. insertion_sort_(function).py' (Steps 2a, 2b, 2b(i) and 2b(ii)) in the 'Tutorial 15 - Insertion Sort (Sorting 
Algorithm)' tutorial)


In short, lets say we are currently at this stage of the Insertion Sort Algorithm on a unsorted List.
(The problem lies in step 2 of the Insertion Sort Algorithm, see step 2 of the Insertion Sort Algorithm
in more detail in '1. What_is_Insertion_Sort.txt' and '2. insertion_sort_(function).py' in the 
'Tutorial 15 - Insertion Sort (Sorting Algorithm)' tutorial)

Visualisation of the problem of Insertion Sort Algorithm that Shell Sort Algorithm solves:
(Step 4, for the fifth element's iteration)
2. Lets say at this stage of Insertion Sort, we want to insert/transfer the element to be 
   inserted/transferred ('4') from unsorted subarray to the sorted subarray of the initial unsorted List.
              ss           us                      (Let 'ss' be the sorted subarray,                  
      <--------------><--------->                       'us' be the unsorted subarray)
      [17][21][29][38][4][25][11]                        'i' be the pointer pointing at the element to be
                       ^                                     inserted/transferred 
                      (i)

   a. In order to do that, we will need to first introduce a pointer (in this case, we will represent it
      with 'j') pointing at the element one index to the left of the inserted element (which will be in 
      the sorted subarray)   
          <--------------><--------->                 
          [17][28][29][38][4][25][11]
                        ^  ^
                       (j)(i) 

   b. Then, this pointer will be traversing in reverse down the sorted subarray, and comparing each element 
      in the sorted subarray to the inserted element in order to find the correct position in the sorted 
      subarray for the inserted element such that the sorted subarray remains sorted. 

 b(i) The comparison being done here is, if the element in the sorted subarray that this pointer is pointing 
      at is larger than the inserted element, we will first need to sort of 'shift' the element this pointer 
      is pointing at to the right index to sort of 'make space' to insert/transfer the inserted element from
      the unsorted subarray to the sorted subarray when we do find a correct position for it. 

      (The algorithmic way the Insertion Sort Algorithm 'shifts' the element the pointer 'j' is pointing 
      at is further explored in '2. insertion_sort_(function).py' in the 
      'Tutorial 15 - Insertion Sort (Sorting Algorithm)' tutorial)

      'Shifting' the element this pointer is pointing at to the right:
                 ss            us    
          <--------------><---------->                  'anchor' (variable) = 4              
          [17][28][29][38][38][25][11]
                        ^   ^
                       (j) (i) 

      Moving pointer 'j' in reverse traversal down the sorted subarray:   
                 ss            us    
          <--------------><---------->                  'anchor' (variable) = 4              
          [17][28][29][38][38][25][11]
                    ^       ^
                   (j)     (i) 

      'Shifting' the element this pointer is pointing at to the right:   
                 ss            us    
          <--------------><---------->                  'anchor' (variable) = 4            
          [17][28][29][29][38][25][11]
                    ^      ^
                   (j)    (i) 


      Moving pointer 'j' in reverse traversal down the sorted subarray:   
                 ss            us    
          <--------------><---------->                  'anchor' (variable) = 4              
          [17][28][29][29][38][25][11]
                ^           ^
               (j)         (i) 

      'Shifting' the element this pointer is pointing at to the right:   
                 ss            us    
          <--------------><---------->                  'anchor' (variable) = 4            
          [17][28][28][29][38][25][11]
                ^           ^
               (j)         (i) 

      Moving pointer 'j' in reverse traversal down the sorted subarray:   
                 ss            us    
          <--------------><---------->                  'anchor' (variable) = 4              
          [17][28][28][29][38][25][11]
            ^               ^
           (j)             (i) 

      'Shifting' the element this pointer is pointing at to the right:   
                 ss            us    
          <--------------><---------->                  'anchor' (variable) = 4            
          [17][17][28][29][38][25][11]
            ^               ^
           (j)             (i) 

      Moving pointer 'j' in reverse traversal down the sorted subarray:   
                 ss            us    
          <--------------><---------->                  'anchor' (variable) = 4              
          [17][17][28][29][38][25][11]
        ^                   ^
       (j)                 (i) 


 b(ii)After finding the correct position in the sorted subarray for the element to be 
      inserted/transferred ('4') from the unsorted subarray to the sorted subarray, we will insert/transfer 
      the inserted element ('4'), using the 'anchor' variable, to the correct position in the sorted
      subarray, at index 0 of the unsorted List.   
                 ss            us    
          <--------------><--------->                  'anchor' (variable) = 4              
          [4][17][28][29][38][25][11]
        ^                  ^
       (j)                (i) 


From this stage of the Insertion Sort Algorithm on a unsorted List, we can see that there will be many,
   -> Comparison 
   -> Shifting/Swapping

operations being done if more of the smaller elements are present towards the end/larger elements being 
present towards the front of the initial unsorted List, which makes the Insertion Sort Algorithm inefficient
in terms of time complexity.

So Shell Sort Algorithm tries to solve this problem. How it does this? Shell Sort aims to somehow try to 
repeatedly move the larger elements in the initial unsorted List towards the end of the initial unsorted List, 
and vice versa (smaller elements in the initial unsorted List towards the front of the initial unsorted List) 
in order to minimise the number of comparison and shifting operations being done in step 2b(i) of the Insertion 
Sort Algorithm. During each Shell Sort's gap's iteration of moving the larger elements in the initial unsorted 
List towards the end of the initial unsorted List, and vice versa, it may not necessarily sort the entire 
initial unsorted List, but after each gap's iteration, the larger elements in the initial unsorted List have been 
shifted slightly towards the end of the initial unsorted List. 

Lets take a look at how Shell Sort works.


//////////////////////////////////////////////


How does Shell Sort Algorithm work?

Here are the steps of Shell Sort Algorithm:
1. Shell Sort Algorithm uses the concept of a gap. You can technically start with a gap of any number, and you
   can decide how you want to decrement it as well every time when the gap is decreased (until when gap becomes 1).
   Usually, Shell Sort uses a gap that is half the size of the initial unsorted List, and we will decrement the gap 
   by half after every gap's iteration (if this gap's iteration's gap is a float/has decimals due to the size of the 
   initial unsorted List being an odd number, then just round down that number to the nearest whole number/integer 
   (e.g. if initial unsorted List size is 9, 9 /2 = 4.5 ~(round down) 4 (which will be this gap's iteration's gap)))

   Note: - There are other methods to decide on the size of the gap and how much to decrement it after each gap's
           iteration but this is the most common method
         - If the gap value is a decimal due to the initial unsorted List having an odd number size, or the previous
           gap value is an odd number, and you got a decimal gap value after halving, just round down that decimal 
           gap value to the nearest whole number/integer

2. We will then create a pointer pointing at the element with index equal to the gap

3. So what does this gap mean? It means that you will have to carry out Insertion Sort at every 'gap'th element in the 
   initial unsorted List to the left of the element this pointer is pointing at inclusive, which will form the smaller 
   subarray. 

   Note: - The smaller subarray does not always only consist of 2 elements. It can contain as many elements as long 
           as they are the 'gap'th elements in the initial unsorted List (that will be seperated by the gap) to the 
           left of the element the pointer 'p' is pointing at inclusive, while we are still within the index range 
           of the initial unsorted List/that the 'gap'th element exists in the initial unsorted List

4. After carrying out Insertion Sort on the smaller subarray, we will move the pointer one index to the right 
   (just one index to the right, not by the gap!) 

5. Repeat steps 3 and 4 until the pointer reaches the end of the initial unsorted List

6. After the pointer has reached the end of the initial unsorted List, we will decrement the gap by half 
   (if this gap's iteration's gap is a float/has decimals due to the previous gap's iteration's gap being an odd
   number, then just round down that number to the nearest whole number/integer (e.g. if previous gap's iteration's
   gap is 7, 7/2 = 3.5 ~(round down) 3 (which will be this gap's iteration's gap)))

   Also notice that the initial unsorted List, after running Insertion Sort through the smaller subarrays, and 
   semi-iterating via the pointer through the initial unsorted List, the larger elements in the initial unsorted List
   have now moved towards the end of the initial unsorted List, and vice versa (smaller elements in the initial 
   unsorted List towards the front of the initial unsorted List). Hence, Insertion Sort should now require fewer 
   number of comparison and shifting operations being done in step 2b(i), thanks to Shell Sort Algorithm. You can 
   clearly see this from the comparison below. This is how Shell Sort solves the problem of Insertion Sort (see 'So 
   what is the problem of Insertion Sort Algorithm that Shell Sort Algorithm solves?' section above)

7. Repeat steps 2 to 6 until gap is less than 1. The last gap's iteration will be guranteed to be gap as 1, 
   regardless of the initial gap value that the Shell Sort algorithm started with (which depends on the size of
   the initial unsorted List)(e.g. 15 /2 ~ 7 /2 ~ 3 /2 ~ 1,  or  9 /2 ~ 4 /2 ~ 2 /2 ~ 1)

   (Note: In code we will just put create step 7 via a while loop, with the condition 'gap > 0' or 'gap >= 1' since
   we want to cut this while loop at the end of the gap (1) iteration, and after the gap is further halved, and 
   rounded down (1 /2 ~ 0.5 ~(round down) ~ 0), gap will definiely be 0 at the next iteration/less than one, proving
   these conditions to be false, and causing the while loop to stop running and exit out of it)


To explain the Shell Sort Algorithm visually, we will be using this unsorted List, 
'[70][3][1][56][34][12][9][13][80]'

Visualisation of how Shell Sort Algorithm works:
1. Shell Sort Algorithm uses the concept of a gap. You can technically start with a gap of any number, and you
   can decide how you want to decrement it as well every time when the gap is decreased (until when gap becomes 1).
   Usually, Shell Sort uses a gap that is half the size of the initial unsorted List, and we will decrement the gap 
   by half after every gap's iteration (if this gap's iteration's gap is a float/has decimals due to the size of the 
   initial unsorted List being an odd number, then just round down that number to the nearest whole number/integer 
   (e.g. if initial unsorted List size is 9, 9 /2 = 4.5 ~(round down) 4 (which will be this gap's iteration's gap)))

   Note: - There are other methods to decide on the size of the gap and how much to decrement it after each gap's
           iteration but this is the most common method
         - If the gap value is a decimal due to the initial unsorted List having an odd number size, or the previous
           gap value is an odd number, and you got a decimal gap value after halving, just round down that decimal 
           gap value to the nearest whole number/integer
      [70][3][1][56][34][12][9][13][80]                  gap = 4




~~~(Starting gap iteration of gap = 4)~~~

2. We will first start by creating a pointer pointing at the element with index equal to the gap, which will be the 
   element at index 4 ('34') in this example. 
      [70][3][1][56][34][12][9][13][80]                  gap = 4           (Let 'p' be the pointer)
                      ^
                     (p)

(Starting iteration, for the fifth element's iteration, of gap iteration of gap = 4)
3. So what does this gap mean? It means that you will have to carry out Insertion Sort at every 4th element in the 
   initial unsorted List (that will be seperated by a gap of 4) to the left of the element this pointer is pointing 
   at inclusive, which will form the smaller subarray. 
   Initial unsorted List before smaller subarray undergo Insertion Sort:
      [70][3][1][56][34][12][9][13][80]                  gap = 4
                      ^
                     (p)

   Smaller subarray before Insertion Sort:                        Smaller subarray after Insertion Sort:
      [70][ ][ ][  ][34][  ][ ][  ][  ]            -->               [34][ ][ ][  ][70][  ][ ][  ][  ] 

   Initial unsorted List after smaller subarray undergo Insertion Sort:
      [34][3][1][56][70][12][9][13][80]                  gap = 4
                      ^
                     (p)

4. After carrying out Insertion Sort on the smaller subarray, we will move the pointer one index to the right 
   (just one index to the right, not by the gap!) 
      [34][3][1][56][70][12][9][13][80]                  gap = 4
                          ^
                         (p)

(Step 5, for the sixth element's iteration, of gap iteration of gap = 4)
3. Then we will repeat the process above, forming the smaller subarray, which will consist of every 4th 
   element in the initial unsorted List (that will be seperated by a gap of 4) to the left of the element this 
   pointer is pointing at inclusive, then carry out Insertion Sort on it.
   Initial unsorted List before smaller subarray undergo Insertion Sort:
      [34][3][1][56][70][12][9][13][80]                  gap = 4
                          ^
                         (p)

   Smaller subarray before Insertion Sort:                        Smaller subarray after Insertion Sort:
      [  ][3][ ][  ][  ][12][ ][  ][  ]            -->               [  ][3][ ][  ][12][  ][ ][  ][  ] 
                                                            (no change since smaller subarray is already sorted)

   Initial unsorted List after smaller subarray undergo Insertion Sort:
      [34][3][1][56][70][12][9][13][80]                  gap = 4
                          ^
                         (p)

4. Similarly, after carrying out Insertion Sort on the smaller subarray, we will move the pointer one index to 
the right again (just one index to the right, not by the gap!) 
      [34][3][1][56][70][12][9][13][80]                  gap = 4
                             ^
                            (p)

For the remaining elements in the initial unsorted List for gap as 4, here is a visualisation on how Shell Sort 
will be like:
(Step 5, for the seventh element's iteration, of gap iteration of gap = 4)
3.
   Initial unsorted List before smaller subarray undergo Insertion Sort:
      [34][3][1][56][70][12][9][13][80]                  gap = 4
                             ^
                            (p)

   Smaller subarray before Insertion Sort:                        Smaller subarray after Insertion Sort:
      [  ][ ][1][  ][  ][  ][9][  ][  ]            -->               [  ][ ][1][  ][  ][  ][9][  ][  ] 
                                                            (no change since smaller subarray is already sorted)

   Initial unsorted List after smaller subarray undergo Insertion Sort:
      [34][3][1][56][70][12][9][13][80]                  gap = 4
                             ^
                            (p)
                         
4.
   Moving the pointer one index to the right
      [34][3][1][56][70][12][9][13][80]                  gap = 4
                                 ^
                                (p)

(Step 5, for the eighth element's iteration, of gap iteration of gap = 4)
3.
   Initial unsorted List before smaller subarray undergo Insertion Sort:
      [34][3][1][56][70][12][9][13][80]                  gap = 4
                                 ^
                                (p)    

   Smaller subarray before Insertion Sort:                        Smaller subarray after Insertion Sort:
      [  ][ ][ ][56][  ][  ][ ][13][  ]            -->               [  ][ ][ ][13][  ][  ][ ][56][  ] 

   Initial unsorted List after smaller subarray undergo Insertion Sort:
      [34][3][1][13][70][12][9][56][80]                  gap = 4
                                 ^
                                (p)

4.                        
   Moving the pointer one index to the right
      [34][3][1][13][70][12][9][56][80]                  gap = 4
                                     ^
                                    (p)

(Step 5, for the ninth element's iteration, of gap iteration of gap = 4)
3. 
   Initial unsorted List before smaller subarray undergo Insertion Sort:
      [34][3][1][13][70][12][9][56][80]                  gap = 4
                                     ^
                                    (p)
                         
   (Notice that the smaller subarray does not always only consist of 2 elements, here it contains 3 elements. It 
   can contain as many elements as long as they are the 'gap'th elements in the initial unsorted List (that will 
   be seperated by the gap) to the left of the element the pointer 'p' is pointing at inclusive, while we are 
   still within the index range of the initial unsorted List/that the 'gap'th element exists in the initial 
   unsorted List)
   Smaller subarray before Insertion Sort:                        Smaller subarray after Insertion Sort:
      [34][ ][ ][  ][70][  ][ ][  ][80]            -->               [34][ ][ ][  ][70][  ][ ][  ][80] 
                                                            (no change since smaller subarray is already sorted)

   Initial unsorted List after smaller subarray undergo Insertion Sort:
      [34][3][1][13][70][12][9][56][80]                  gap = 4
                                     ^
                                    (p)

4. No need to shift the pointer one index to the right since we are at the end of the initial unsorted List


6. After the pointer has reached the end of the initial unsorted List, we will decrement the gap by half, and instead
   of gap as 4, the gap will now be 2. 

   Also notice that the initial unsorted List, after running Insertion Sort through the smaller subarrays, and 
   semi-iterating via the pointer through the initial unsorted List, the larger elements in the initial unsorted List
   have now moved towards the end of the initial unsorted List, and vice versa (smaller elements in the initial 
   unsorted List towards the front of the initial unsorted List). Hence, Insertion Sort should now require fewer 
   number of comparison and shifting operations being done in step 2b(i), thanks to Shell Sort Algorithm. You can 
   clearly see this from the comparison below. This is how Shell Sort solves the problem of Insertion Sort (see 'So 
   what is the problem of Insertion Sort Algorithm that Shell Sort Algorithm solves?' section above)
   Initial unsorted List before running Shell Sort through the initial unsorted List:
         [70][3][1][56][34][12][9][13][80]

   Now partially sorted, initial unsorted List after running Shell Sort through the initial unsorted List with gap as 2:
         [34][3][1][13][70][12][9][56][80]



Now, we will repeat the above process, but with gap as 2.
~~~(Step 7, for gap iteration of gap = 2)~~~

2. We will first start by creating a pointer pointing at the element with index equal to the gap, which will be the 
element at index 2 ('1') in this example.
      [34][3][1][13][70][12][9][56][80]                  gap = 2           (Let 'p' be the pointer)
              ^
             (p)

(Starting iteration, for the third element's iteration, of gap iteration of gap = 2)
3. So what does this gap mean? It means that you will have to carry out Insertion Sort at every 2nd element in the 
   initial unsorted List (that will be seperated by a gap of 2) to the left of the element this pointer is pointing 
   at inclusive, which will form the smaller subarray. 
   Initial unsorted List before smaller subarray undergo Insertion Sort:
      [34][3][1][13][70][12][9][56][80]                  gap = 2
              ^
             (p)

   Smaller subarray before Insertion Sort:                        Smaller subarray after Insertion Sort:
      [34][ ][1][  ][  ][  ][ ][  ][  ]            -->               [1][ ][34][  ][  ][  ][ ][  ][  ] 

   Initial unsorted List after smaller subarray undergo Insertion Sort:
      [1][3][34][13][70][12][9][56][80]                  gap = 2
              ^
             (p)

4. After carrying out Insertion Sort on the smaller subarray, we will move the pointer one index to the right 
   (just one index to the right, not by the gap!) 
      [1][3][34][13][70][12][9][56][80]                  gap = 2
                  ^
                 (p)

(Step 5, for the fourth element's iteration, of gap iteration of gap = 2)
3. Then we will repeat the process above, forming the smaller subarray, which will consist of every 2nd 
   element in the initial unsorted List (that will be seperated by a gap of 2) to the left of the element this 
   pointer is pointing at inclusive, then carry out Insertion Sort on it.
      [1][3][34][13][70][12][9][56][80]                  gap = 2
                  ^
                 (p)

   Smaller subarray before Insertion Sort:                        Smaller subarray after Insertion Sort:
      [ ][3][  ][13][  ][  ][ ][  ][  ]            -->               [ ][3][  ][13][  ][  ][ ][  ][  ]
                                                            (no change since smaller subarray is already sorted)

   Initial unsorted List after smaller subarray undergo Insertion Sort:
      [1][3][34][13][70][12][9][56][80]                  gap = 2
                  ^
                 (p)

4. Similarly, after carrying out Insertion Sort on the smaller subarray, we will move the pointer one index to 
   the right again (just one index to the right, not by the gap!) 
      [1][3][34][13][70][12][9][56][80]                  gap = 2
                      ^
                     (p)

For the remaining elements in the initial unsorted List for gap as 2, here is a visualisation on how Shell Sort 
will be like:
(Step 5, for the fifth element's iteration, of gap iteration of gap = 2)
3. 
   Initial unsorted List before smaller subarray undergo Insertion Sort:
      [1][3][34][13][70][12][9][56][80]                  gap = 2
                      ^
                     (p)

   (Notice that the smaller subarray does not always only consist of 2 elements, here it contains 3 elements. It 
   can contain as many elements as long as they are the 'gap'th elements in the initial unsorted List (that will 
   be seperated by the gap) to the left of the element the pointer 'p' is pointing at inclusive, while we are 
   still within the index range of the initial unsorted List/that the 'gap'th element exists in the initial 
   unsorted List)
   Smaller subarray before Insertion Sort:                        Smaller subarray after Insertion Sort:
      [1][ ][34][  ][70][  ][ ][  ][  ]            -->               [1][ ][34][  ][70][  ][ ][  ][  ] 
                                                            (no change since smaller subarray is already sorted)

   Initial unsorted List after smaller subarray undergo Insertion Sort:
      [1][3][34][13][70][12][9][56][80]                  gap = 2
                      ^
                     (p)
                         
4.
   Moving the pointer one index to the right
      [1][3][34][13][70][12][9][56][80]                  gap = 2
                          ^
                         (p)

(Step 5, for the sixth element's iteration, of gap iteration of gap = 2)
3.
   Initial unsorted List before smaller subarray undergo Insertion Sort:
      [1][3][34][13][70][12][9][56][80]                  gap = 2
                          ^
                         (p)

   Smaller subarray before Insertion Sort:                        Smaller subarray after Insertion Sort:
      [ ][3][  ][13][  ][12][ ][  ][  ]            -->               [ ][3][  ][12][  ][13][ ][  ][  ] 

   Initial unsorted List after smaller subarray undergo Insertion Sort:
      [1][3][34][12][70][13][9][56][80]                  gap = 2
                          ^
                         (p)

4.
   Moving the pointer one index to the right
      [1][3][34][12][70][13][9][56][80]                  gap = 2
                             ^
                            (p)

(Step 5, for the seventh element's iteration, of gap iteration of gap = 2)
3.
   Initial unsorted List before smaller subarray undergo Insertion Sort:
      [1][3][34][12][70][13][9][56][80]                  gap = 2
                             ^
                            (p)
                         
(Notice here is when Insertion sort comes to play, not just swapping the last 2 elements in the smaller subarray everytime only!!)
   Smaller subarray before Insertion Sort:                        Smaller subarray after Insertion Sort:
      [1][ ][34][  ][70][  ][9][  ][  ]            -->               [1][ ][9][  ][34][  ][70][  ][  ] 


   Initial unsorted List after smaller subarray undergo Insertion Sort:
      [1][3][9][12][34][13][70][56][80]                  gap = 2
                             ^
                            (p)

4.
   Moving the pointer one index to the right
      [1][3][9][12][34][13][70][56][80]                  gap = 2
                                 ^
                                (p)

(Step 5, for the eighth element's iteration, of gap iteration of gap = 2)
3.
   Initial unsorted List before smaller subarray undergo Insertion Sort:
      [1][3][9][12][34][13][70][56][80]                  gap = 2
                                 ^
                                (p)           

   Smaller subarray before Insertion Sort:                        Smaller subarray after Insertion Sort:
      [ ][3][  ][12][  ][13][  ][56][  ]            -->               [ ][3][  ][12][  ][13][  ][56][  ] 
                                                            (no change since smaller subarray is already sorted)

   Initial unsorted List after smaller subarray undergo Insertion Sort:
      [1][3][9][12][34][13][70][56][80]                  gap = 2
                                 ^
                                (p)     

4.
   Moving the pointer one index to the right
      [1][3][9][12][34][13][70][56][80]                  gap = 2
                                     ^
                                    (p)

(Step 5, for the ninth element's iteration, of gap iteration of gap = 2)
3. 
   Initial unsorted List before smaller subarray undergo Insertion Sort:
      [1][3][9][12][34][13][70][56][80]                  gap = 2
                                     ^
                                    (p)           

   Smaller subarray before Insertion Sort:                        Smaller subarray after Insertion Sort:
      [1][ ][9][  ][34][  ][70][  ][80]            -->               [1][ ][9][  ][34][  ][70][  ][80] 
                                                            (no change since smaller subarray is already sorted)

   Initial unsorted List after smaller subarray undergo Insertion Sort:
      [1][3][9][12][34][13][70][56][80]                  gap = 2
                                     ^
                                    (p)     

4. No need to shift the pointer one index to the right since we are at the end of the initial unsorted List


6. After the pointer has reached the end of the initial unsorted List, we will decrement the gap by half, and instead
   of gap as 2, the gap will now be 1. 

   Also notice that the initial unsorted List, after running Insertion Sort through the smaller subarrays, and 
   semi-iterating via the pointer through the initial unsorted List, the larger elements in the initial unsorted List
   have now moved towards the end of the initial unsorted List, and vice versa (smaller elements in the initial 
   unsorted List towards the front of the initial unsorted List). Hence, Insertion Sort should now require fewer 
   number of comparison and shifting operations being done in step 2b(i), thanks to Shell Sort Algorithm. You can 
   clearly see this from the comparison below. This is how Shell Sort solves the problem of Insertion Sort (see 'So 
   what is the problem of Insertion Sort Algorithm that Shell Sort Algorithm solves?' section above)
   Initial unsorted List before running Shell Sort through the initial unsorted List:
         [70][3][1][56][34][12][9][13][80]

   Now partially sorted, initial unsorted List after running Shell Sort through the initial unsorted List with gap as 4:
         [34][3][1][13][70][12][9][56][80]

   Now partially sorted, initial unsorted List after running Shell Sort through the initial unsorted List with gap as 2:
         [1][3][9][12][34][13][70][56][80]


After the gap (2) iteration, the now partially sorted, initial unsorted List only have 2 elements out of place 
(elements '13' and '56'), which only require one swap with the element preceding them in order to put them in the
correct place by the next gap (1) iteration of Shell Sort, which is coincidentally the standard Insertion Sort 
(how the next gap (1) iteration of Shell Sort is coincidentally the standard Insertion will be explained down 
below). This now partially sorted, initial unsorted List from Shell Sort allows minimal comparison and 
shifting/swapping operations from the Insertion Sort (that is, the last/next gap (1) iteration of Shell Sort),
hence proving that Shell Sort is an optimization of Insertion Sort.



Now, we will repeat the above process, but with gap as 1, which is also the final gap iteration of Shell Sort (which 
is basically the standard Insertion Sort). Here is the first few steps of this gap's (1) iteration, to more clearly 
demonstrate that during this final gap (1) iteration of Shell Sort is basically the standard Insertion Sort.
~~~(Step 7, for gap iteration of gap = 1)~~~

2. We will first start by creating a pointer pointing at the element with index equal to the gap, which will be the 
   element at index 1 ('3') (the second element in the now partially sorted, initial unsorted List) in this example.

      [1][3][9][12][34][13][70][56][80]                  gap = 1           (Let 'p' be the pointer)
          ^
         (p)

(Starting iteration, for the second element's iteration, of gap iteration of gap = 1)
3. So what does this gap mean? It means that you will have to carry out Insertion Sort at every 1st element in the 
   initial unsorted List (that will be seperated by a gap of 1) to the left of the element this pointer is pointing 
   at inclusive, which will form the smaller subarray. 
   Initial unsorted List before smaller subarray undergo Insertion Sort:
      [1][3][9][12][34][13][70][56][80]                  gap = 1
          ^
         (p)

   Smaller subarray before Insertion Sort:                        Smaller subarray after Insertion Sort:
      [1][3][ ][  ][  ][  ][ ][  ][  ]            -->               [1][3][ ][  ][  ][  ][ ][  ][  ] 
                                                            (no change since smaller subarray is already sorted)

   Initial unsorted List after smaller subarray undergo Insertion Sort:
      [1][3][9][12][34][13][70][56][80]                  gap = 1
          ^
         (p)

4. After carrying out Insertion Sort on the smaller subarray, we will move the pointer one index to the right 
   (just one index to the right, not by the gap!) 
      [1][3][9][12][34][13][70][56][80]                  gap = 1
             ^
            (p)

(Step 5, for the third element's iteration, of gap iteration of gap = 1)
3. Then we will repeat the process above, forming the smaller subarray, which will consist of every 2nd 
   element in the initial unsorted List (that will be seperated by a gap of 2) to the left of the element this 
   pointer is pointing at inclusive, then carry out Insertion Sort on it.
      [1][3][9][12][34][13][70][56][80]                  gap = 1
             ^
            (p)

   Smaller subarray before Insertion Sort:                        Smaller subarray after Insertion Sort:
      [1][3][9][  ][  ][  ][ ][  ][  ]            -->               [1][3][9][  ][  ][  ][ ][  ][  ]
                                                            (no change since smaller subarray is already sorted)

   Initial unsorted List after smaller subarray undergo Insertion Sort:
      [1][3][9][12][34][13][70][56][80]                  gap = 1
             ^
            (p)

4. Similarly, after carrying out Insertion Sort on the smaller subarray, we will move the pointer one index to 
   the right again (just one index to the right, not by the gap!) 
      [1][3][9][12][34][13][70][56][80]                  gap = 1
                 ^
                (p)

...

and so on until the end of the gap (1) iteration of Shell Sort, which is also basically the standard Insertion Sort,
where the initial unsorted List will now be sorted.
      [1][3][9][12][13][34][56][70][80]                  gap = 1
                                     ^
                                    (p)

7. After gap is halved and rounded down to the nearest whole number/integer at the end of the gap (1) iteration, 
   which will be 0, and which will be less than 1, hence marking the end of the Shell Sort Algorithm


Notice, during the final gap iteration in Shell Sort, with gap as 1, isn't the steps shown in this gap's (1) 
iteration of Shell Sort looks awfully similar to the standard Insertion Sort? Thats because this gap's (1) iteration 
of Shell Sort is the standard Insertion Sort. Previously, all the gap's iterations do use Insertion Sort, but they 
weren't the standard Insertion Sort due to the presence of gaps between the elements in the smaller subarrays. 


//////////////////////////////////////////


Explaining the Big O Notation of Time and Space Complexity of Shell Sort:

For Big O Notation of Time Complexity of Shell Sort:
Shell Sort's time complexity is more complex to analyze than some other sorting algorithms due to its dependence on 
the gap sequence chosen and the input data's characteristics (which will affect the number of comparisons and 
shifts/swapping operations required). The time complexity can vary based on these factors.

   - Number of Comparisons: The number of comparisons is a significant factor in determining the time complexity of 
     Shell Sort. As the gap decreases, the subarrays become smaller, and the number of comparisons within each subarray 
     decreases. However, the number of comparisons between subarrays might increase.
   - Number of Shifts: Shell Sort reduces the number of shifts compared to Insertion Sort. The larger gaps move 
     elements more quickly toward their correct positions, reducing the need for many shifts. As the gap decreases, 
     the shifts are concentrated on smaller subarrays, which are easier to manage.
   - The choice of gap sequence plays a crucial role in determining how the algorithm performs. A gap sequence that 
     ensures a good spread of comparisons and shifts across the elements tends to result in better performance.

For a best sorting testcase (Best Case Time Complexity): 
Shell Sort's best-case time complexity depends on the gap sequence. For the best gap sequences, the best-case time 
complexity can be close to O(n log n).

For an average sorting testcase (Average Case Time Complexity):
The average-case time complexity of Shell Sort is harder to determine due to the varying gap sequences and input 
data distributions. It is generally considered better than O(n^2) and often closer to O(n log n). Some gap sequences, 
like those based on the Knuth Sequence, tend to provide better average-case performance.

For a worst sorting testcase (Worst Case Time Complexity): 
The worst-case time complexity of Shell Sort is generally O(n^2) for most gap sequences. However, certain gap 
sequences, such as Sedgewick's gap sequence, can achieve worst-case time complexity of O(n^(3/2)) or even 
O(n log^2 n).

In summary, Shell Sort's time complexity analysis is complex due to its dependency on gap sequences and input data 
distribution. While its worst-case time complexity might not be as optimal as some other algorithms, its adaptiveness 
and reduced shifts can lead to better average and practical performance, especially when used with suitable gap 
sequences.


For Big O Notation of Space Complexity of Shell Sort:
It is Big O Notation Space Complexity of O(1) because when you are sorting the elements in the unsorted 
List, you are not using any additional variables/memory (at least any additional variables/memory 
proportional to the input size to perform the sorting process), and just doing the sorting process within 
the same unsorted List. At most you are just using extra variables to facilitate the sorting of the unsorted 
List, but since this amount of space/memory used is fixed regardless of the n size of the List it means 
that the Big O Notation of Space Complexity is still O(1).


//////////////////////////////////////////


Comparing Big O Notation of Time Complexity of Insertion Sort and Shell Sort:

For reference,
   Big O Notation of Time and Space Complexity for Insertion Sort Algorithm and Shell Sort Algorithm:
        Sorting Algorithms   |   Space Complexity   |   Time Complexity
          Insertion Sort     |        O(1)	  	    |       O(n^2)
           Shell Sort        |        O(1)	  	    |       O(n^2)

Despite having the same Big O Notation of Time Complexity, O(n^2), for most testcases, Shell Sort 
outperforms Insertion Sort due to the problem of Insertion Sort that Shell Sort solves as explained in
the 'So what is the problem of Insertion Sort Algorithm that Shell Sort Algorithm solves?' section. 


//////////////////////////////////////////


Advantages and Disadvantages of Shell Sort Algorithm compared to other sorting algorithms:

Advantages of Shell Sort:
1. Improved Insertion Sort: Shell Sort is an improvement over the basic Insertion Sort algorithm. By 
   sorting elements with larger gaps before reducing the gaps, it moves elements closer to their correct 
   positions earlier in the sorting process. This reduces the number of comparisons and swaps needed 
   during the final Insertion Sort phase.
2. Efficiency on Medium-Sized Lists: Shell Sort performs well on medium-sized lists, where the number 
   of elements is not too small or too large. It can outperform other quadratic sorting algorithms like 
   bubble Sort and Insertion Sort in this range.
3. In-Place Sorting: Shell Sort is an in-place sorting algorithm, which means it doesn't require 
   additional memory for temporary storage of elements. It operates directly on the input array, making 
   it memory-efficient.
4. Adaptable Gap Sequences: The choice of gap sequence in Shell Sort can be adapted based on the data 
   being sorted. Different gap sequences can provide different levels of performance for different types 
   of input data.

Disadvantages of Shell Sort:
1. Non-Stable Sort: Shell Sort is not a stable sorting algorithm, meaning that the relative order of 
   equal elements might change after sorting.
2. Complexity of Gap Sequences: The effectiveness of Shell Sort is influenced by the choice of gap 
   sequence. While some sequences work well for certain inputs, finding an optimal sequence for general 
   use can be complex and might require experimentation.
3. Time Complexity Variability: The time complexity of Shell Sort varies depending on the gap sequence 
   used. While it has an average-case time complexity between O(n log^2 n) and O(n^(3/2)), the exact 
   performance can be difficult to predict due to the dependence on the gap sequence.
4. Not the Fastest Option: While Shell Sort is an improvement over quadratic algorithms like Bubble 
   Sort and Insertion Sort, it's not as fast as more advanced sorting algorithms like Quick Sort, Merge
   Sort, or Heap Sort on larger datasets.


/////////////////////////////////////////


Why is Shell Sort called 'Shell Sort'?

Shell sort is called as such because it is named after its inventor, Donald Shell. Donald L. Shell, an 
American computer scientist, who developed the algorithm.


//////////////////////////////////////////


Big O Notation of Time and Space Complexity for Shell Sort Algorithm:

    Sorting Algorithms   |  Space Complexity  |   Time Complexity
       Shell Sort        |        O(1)	  	    |       O(n^2)

