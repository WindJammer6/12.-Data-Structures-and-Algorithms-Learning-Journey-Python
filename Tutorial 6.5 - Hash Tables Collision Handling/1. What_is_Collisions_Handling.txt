What is a Collision in Hash Tables? And what is the Problem of Collisions when making Hash 
Tables?
A Collision occurs when more than one value (of key-pair values) is hashed by a particular hash function
hash to the same slot/produces the same hash (or index in the memory array) in the Hash Table being 
generated by that hash function.

Visual representation of a collision:
In memory:
                                                              Index:
march 6 (key) -> [hash function] -------       ---> [  400  ]   1
                                        |     |     [       ]   2
march 2 (key) -> [hash function] -------|-----      [       ]   3                                         
                                        |           [       ]   4
march 7 (key) -> [hash function] --     |           [       ]   5
                                   \    |           [       ]   6
                                    \    \          [       ]   7
december 17 (key) -> [hash function] \     -------> [  310  ]   8
                                   |  \             [       ]   9 
                                    --------------> [  340  ]   10

for stock_prices["december 17"] = 300

The collision in this visual representation is when both "march 7" and "december 17" keys are trying to 
store their values in the same location. So we will have to do some spacial handling, which is known as
Collision Handling.


///////////////////////////////////


What is Collision Handling?
Collision Handling is when we modify our existing Hash Table Data Structure such that it is able to
handle these Collisions and still be able to store every key-value pair being given to it at a unique
spot in the Hash Table's memory array such that they are still unique and won't override or affect other 
key-value pairs in the Hash Table.

How can we modify our Hash Table Data Structures such that it handles collisions?
As of now, the Hash Table that we implemented in '8. converting_Instance_Methods_to_Special_Methods.py'
is unable to handle collisions, and if a key of a newly added key-value pair provides a hash by the hash
function that is of the same hash/index of an existing key-value pair already in the Hash Table Data
Structure, then it will override and delete the existing key-value pair at that hash/index to make space
to place its own key-value pair.


//////////////////////////////////////


So how can we do Collisions Handling?
There are 2 ways:
    1. Seperate Chaining (we will be implementing this modification in the next few files to our 
                          existing Hash Table Data Structure from 
                          '8. converting_Instance_Methods_to_Special_Methods.py')
    2. Linear Probing (we will be implementing this modification in the Excercises to our 
                       existing Hash Table Data Structure from 
                       '8. converting_Instance_Methods_to_Special_Methods.py')


//////////////////////////////////////


What is Seperate Chaining and how does it hanlde collisions in our Hash Table Data Structure?

Visual representation of Seperate Chaining (do note that the hash function is not the same as the one
we are using in the tutorial):
In memory:
                                                              Index:    
march 6 (key) -> [hash function] -------       ---> [       ]   1   --> ("march 2",400)
                                        |     |     [       ]   2
march 2 (key) -> [hash function] -------|-----      [       ]   3                                         
                                        |           [       ]   4
march 7 (key) -> [hash function] --     |           [       ]   5
                                   \    |           [       ]   6
                                    \    \          [       ]   7
december 17 (key) -> [hash function] \     -------> [       ]   8   --> ("march 2",310)
                                   |  \             [       ]   9 
                                    --------------> [       ]   10  --> ("march 7",340) --> ("december 17",300)

In Seperate Chaining, instead of storing a key-value pair's value at each location in the memory array of
a Hash Table Data Structure, we store a pointer (an address in the location) which acts as a starter for 
a Linked List, pointing to the first Node, where we can store our multiple key-value pairs (NOTE that in
each Node we store both the key and value in a Tuple (Static Array) instead of just the value that a 
normal Hash Table does in each index in the memory array for accessing purposes) that coincidentally have
the same hash/index produced by the hash function as unique key-value pairs that does not override each 
other in memory.

So when we append a new key-value pair into the Hash Table Data Structure that has an existing key-value
pair of the same hash/index, instead of overriding the existing key-value pair at that hash/index, it
will be appended to the Linked List at that hash/index in array memory.

This way, the Linked List can keep growing, and multiple keys of different key-value pairs can share the 
same hash/index.


What is the Big O Notation of Time Complexity for Seperate Chaining Hash Tables?
For a normal Hash Table, the Big O Notation of Time Complexity for Search is O(1). However, for the
Seperate Chaining Hash Table, it is O(n). Imagine you have a really bad hash function which maps every
key-value pair to the same index, then you will have a very long Linked List. Hence, to search such a 
Hash Table, which is now essentially just a Linked List, will have the same Big O Notation of Time 
Complexity for Search as a Linked List, which is O(n).
(Note: Seperate Chaining Hash Tables's Big O Notation of Time Complexity for Insertion and Deletion is
still O(1) though (same as Linked Lists))


How do we access a specific key-value pair in a Seperate Chaining Hash Table? (for example, a key-value
pair at the second Node of one of the Linked List such as ("december 17", 300))
First we will need to use the hash function to find the hash/index in the memory array of the Hash Table
Data Structure. Then we will Linearly Search the Linked List for the key-value pair and hence it is for
this reason why we need to store our key together with our value in each element/Node so that we can
identify which key-value pair is the value that we are looking for within the Linked List.


//////////////////////////////////////


What is Linear Probing and how does it hanlde collisions in our Hash Table Data Structure?

Visual representation of Linear Probing(do note that the hash function is not the same as the one
we are using in the tutorial):
In memory:
                                                                           Index:    
march 6 (key) -> [hash function] -------       ---> [   ("march 2",400)  ]   1
                                        |     |     [                    ]   2
march 2 (key) -> [hash function] -------|-----      [                    ]   3                                         
                                        |           [                    ]   4
march 7 (key) -> [hash function] --     |           [                    ]   5
                                   \    |           [                    ]   6
                                    \    \          [                    ]   7
december 17 (key) -> [hash function] \     -------> [   ("march 2",310)  ]   8
                          (10)        \             [                    ]   9 
                                       -----------> [   ("march 7",340)  ]   10
for stock_prices["december 17"] = 300

In Linear Probing, we're back to storing inside the index of the Hash Table's memory array, but instead
of just the value of key-pair values, we are storing both the key and value in a Tuple (like for each
Node in the Linked Lists in the Seperate Chaining Hash Table). 

So when we append a new key-value pair into the Hash Table Data Structure that has an existing key-value
pair of the same hash/index, such as the appending of "december 17", which gives the same hash/index (10)
as an exisiting key-value pair, "march 7", as the name Linear Probing suggests, we will Linearly Probe 
(search) for the next available index in the memory array (that does not have a key-value pair stored in 
it yet). Since index 11 does not exist, the program will go back to the top, index 1, to see if its 
available. Since it is already occupied, we will search the next index, index 2 if its available. Since, 
it is available, we will store our new key-value pair, "december 17" there, as shown below.

Visual representation of Linear Probing:
In memory:
                                                                           Index:    
march 6 (key) -> [hash function] -------       ---> [   ("march 2",400)  ]   1
                                        |     | --> [("december 17", 300)]   2
march 2 (key) -> [hash function] -------|----- /    [                    ]   3                                         
                                        |  ----     [                    ]   4
march 7 (key) -> [hash function] --     | /         [                    ]   5
                                   \    |/          [                    ]   6
                                    \   /\          [                    ]   7
december 17 (key) -> [hash function] ---   -------> [   ("march 2",310)  ]   8
                          (10)        \             [                    ]   9 
                                       -----------> [   ("march 7",340)  ]   10
for stock_prices["december 17"] = 300


What is the Big O Notation of Time Complexity for Linear Probing Hash Tables?



How do we access a specific key-value pair in a Linear Probing Hash Table? 

